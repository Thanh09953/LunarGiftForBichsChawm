<!DOCTYPE html>
<html>
<head>
    <title>T·∫∑ng b√© iu B√≠ch ChƒÉm c·ªßa anh chi·∫øc b√°nh trung thuü•∞</title>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: white;
            font-family: Arial, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            z-index: 100; 
        }

        #startButton {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #ff005c;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0 0 15px #ff005c; 
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="message">
        <p>B√≠ch ChƒÉm y√™u d·∫•u, T·∫∑ng b√© iu chi·∫øc ‚Äúb√°nh trung thu‚Äù b·∫•t ng·ªù t·ª´ anh ü•∞</p>
        <button id="startButton">B·∫•m ƒë·ªÉ m·ªü qu√†</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
    <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>

    <script>
        let scene, camera, renderer;
        let characters = [];
        let clock = new THREE.Clock();
        let audioContext, musicSource;
        let reflectionCylinder; 

        // L·ªùi nh·∫Øn s·∫Ω t·∫°o n√™n h√¨nh tr√°i tim 3D
        const WORDS = "B√≠ch ChƒÉm y√™u anh m√£i m√£i l√† ƒëi·ªÅu tuy·ªát v·ªùi nh·∫•t m√† anh c√≥ ƒë∆∞·ª£c! H·∫πn th·ªÅ l√∫c x∆∞a s·∫Ω kh√¥ng xa r·ªùi. Y√™u Love Forever M√£i M√£i";
        const PARTICLE_COUNT_MULTIPLIER = 12;

        // --- H√ÄM T·∫†O H√åNH TR√ÅI TIM 3D ---
        function getHeartPosition(t, scale = 12) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            const z = (Math.random() - 0.5) * 10;
            return new THREE.Vector3(x * scale, (y * scale) - 50, z);
        }

        // --- KH·ªûI T·∫†O THREE.JS V√Ä HI·ªÜU ·ª®NG ---
        function init() {
            // 1. Scene & Camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150;

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // 3. √Ånh s√°ng (C∆∞·ªùng ƒë·ªô cao)
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5); 
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xff005c, 10, 500); 
            pointLight.position.set(0, 50, 50);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0xff005c, 5, 500); 
            pointLight2.position.set(0, -100, 0);
            scene.add(pointLight2);
            
            // 4. H√¨nh tr·ª• gi·∫£ l·∫≠p ph·∫£n chi·∫øu (Reflection Cylinder)
            const cylinderGeometry = new THREE.CylinderGeometry(60, 100, 5, 64);
            const cylinderMaterial = new THREE.MeshLambertMaterial({
                color: 0x0a0a0a,
                transparent: true,
                opacity: 0.8,
                emissive: 0x88003a, 
                emissiveIntensity: 1.5 
            });
            reflectionCylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            reflectionCylinder.position.y = -100;
            scene.add(reflectionCylinder);

            // 5. T·∫°o c√°c H·∫°t (Ch·ªØ c√°i)
            const filteredWords = WORDS.split('').filter(char => char.trim() !== '');
            const totalParticles = filteredWords.length * PARTICLE_COUNT_MULTIPLIER;

            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                
                for (let i = 0; i < totalParticles; i++) {
                    const char = filteredWords[i % filteredWords.length];
                    
                    const geometry = new THREE.TextGeometry(char, {
                        font: font,
                        size: 3,
                        height: 0.5,
                    });
                    
                    const material = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(Math.random() * 0.2 + 0.8, 1, 0.9), 
                        emissive: new THREE.Color(0xff88aa), 
                        emissiveIntensity: 2 
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // V·ªã tr√≠ ban ƒë·∫ßu ng·∫´u nhi√™n (t·∫°o hi·ªáu ·ª©ng b√πng n·ªï)
                    mesh.position.set(
                        (Math.random() - 0.5) * 400,
                        (Math.random() - 0.5) * 400,
                        (Math.random() - 0.5) * 400
                    );
                    
                    mesh.userData.targetT = Math.random() * Math.PI * 2;
                    mesh.userData.originalEmissiveIntensity = 2; 
                    
                    characters.push(mesh);
                    scene.add(mesh);
                }

                animate();
            });
        }

        // --- V√íNG L·∫∂P RENDER (CH·∫†Y CODE) ---
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            characters.forEach(mesh => {
                // Di chuy·ªÉn nhanh v·ªÅ h√¨nh tr√°i tim
                const targetPos = getHeartPosition(mesh.userData.targetT);
                mesh.position.lerp(targetPos, 0.15); 

                // Xoay nh·∫π t·ª´ng h·∫°t
                mesh.rotation.x += 0.05; 
                mesh.rotation.y += 0.05; 

                // Hi·ªáu ·ª©ng L·∫•p L√°nh C∆∞·ªùng ƒê·ªô Cao
                const flicker = Math.sin(time * 15 + mesh.userData.targetT) * 0.5 + 0.5;
                mesh.material.emissiveIntensity = mesh.userData.originalEmissiveIntensity * (0.5 + flicker * 0.5);
                
            });

            // Xoay to√†n b·ªô tr√°i tim v√† h√¨nh tr·ª• ph·∫£n chi·∫øu
            scene.rotation.y = time * 0.15;
            if (reflectionCylinder) {
                reflectionCylinder.rotation.y = -time * 0.3;
            }

            renderer.render(scene, camera);
        }

        // --- X·ª¨ L√ù √ÇM THANH ---
        async function setupAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // File nh·∫°c c·∫ßn n·∫±m c√πng th∆∞ m·ª•c
                const response = await fetch('music.mp3'); 
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                musicSource = audioContext.createBufferSource();
                musicSource.buffer = audioBuffer;
                musicSource.loop = true;

                musicSource.connect(audioContext.destination);
                
                musicSource.start(0);

            } catch (error) {
                console.error("L·ªói khi t·∫£i ho·∫∑c ph√°t nh·∫°c:", error);
            }
        }

        // --- K√çCH HO·∫†T B·∫∞NG NH·∫§P V√ÄO M√ÄN H√åNH ---
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('message').style.display = 'none';
            
            init(); // B·∫Øt ƒë·∫ßu 3D
            setupAudio(); // B·∫Øt ƒë·∫ßu nh·∫°c
        });

        window.addEventListener('resize', () => {
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
